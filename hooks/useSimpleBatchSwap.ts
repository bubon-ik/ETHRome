/**
 * Simple Batch Swap Hook - –±–µ–∑ Fusion SDK
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç wagmi sendCalls –¥–ª—è batch —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
 * 
 * @see https://wagmi.sh/core/api/actions/sendCalls
 */

import { useState, useCallback } from 'react';
import { useAccount, useWaitForTransactionReceipt, usePublicClient } from 'wagmi';
import { sendCalls, getCallsStatus, waitForCallsStatus } from '@wagmi/core';
import { getWagmiConfig } from '@/lib/wagmi';
import { parseUnits, type Address } from 'viem';
import { SwapRoute } from '@/types';
import { simpleSwapService, type SwapParams, type BatchSwapCall } from '@/lib/simple-swap';

export interface BatchSwapParams {
  routes: SwapRoute[];
  recipient: string;
  deadline: number;
  slippage: number;
}

export interface UseSimpleBatchSwapReturn {
  executeBatchSwap: (params: BatchSwapParams) => Promise<void>;
  resetState: () => void;
  isLoading: boolean;
  error: string | null;
  txHash: string | null;
  batchId: string | null;
  isSuccess: boolean;
  callsCount: number;
}

export function useSimpleBatchSwap(): UseSimpleBatchSwapReturn {
  const { address, chain } = useAccount();
  const publicClient = usePublicClient();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [txHash, setTxHash] = useState<string | null>(null);
  const [batchId, setBatchId] = useState<string | null>(null);
  const [isSuccess, setIsSuccess] = useState(false);
  const [callsCount, setCallsCount] = useState(0);

  const { data: transactionReceipt } = useWaitForTransactionReceipt({
    hash: txHash as `0x${string}` | undefined,
  });

  /**
   * –í—ã–ø–æ–ª–Ω–∏—Ç—å batch swap —á–µ—Ä–µ–∑ sendCalls
   */
  const executeBatchSwap = useCallback(async (params: BatchSwapParams) => {
    if (!address) {
      setError('Wallet not connected');
      return;
    }

    if (!chain) {
      setError('No chain connected');
      return;
    }

    setIsLoading(true);
    setError(null);
    setTxHash(null);
    setBatchId(null);
    setIsSuccess(false);
    setCallsCount(0);

    let currentBatchId: string | null = null;

    try {
      console.log('üöÄ Starting simple batch swap...');

      // –í–∞–ª–∏–¥–∞—Ü–∏—è routes
      const validRoutes = params.routes.filter(route => 
        route.from.amount && parseFloat(route.from.amount) > 0
      );

      if (validRoutes.length === 0) {
        throw new Error('No valid routes provided');
      }

      console.log(`üìù Processing ${validRoutes.length} swap routes...`);

      // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º swap –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
      const swapParams: SwapParams[] = validRoutes.map(route => ({
        fromToken: route.from,
        toToken: route.to,
        amount: route.from.amount,
        walletAddress: address,
        slippage: params.slippage,
      }));

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –Ω—É–∂–µ–Ω –ª–∏ batch –∏–ª–∏ –æ–¥–∏–Ω–æ—á–Ω—ã–π swap
      let calls;
      if (swapParams.length === 1) {
        // –û–¥–∏–Ω–æ—á–Ω—ã–π swap - –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—É—é –ª–æ–≥–∏–∫—É
        calls = await simpleSwapService.prepareSingleSwapCall(swapParams[0]);
      } else {
        // –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Å–≤–∞–ø—ã - –∏—Å–ø–æ–ª—å–∑—É–µ–º batch –ª–æ–≥–∏–∫—É
        calls = await simpleSwapService.prepareBatchSwapCalls({
          swaps: swapParams,
          walletAddress: address,
          slippage: params.slippage,
        });
      }

      setCallsCount(calls.length);
      console.log(`üì¶ Prepared ${calls.length} batch calls`);

      if (calls.length === 0) {
        throw new Error('No calls prepared');
      }

      // –í—ã–ø–æ–ª–Ω—è–µ–º batch —á–µ—Ä–µ–∑ sendCalls (EIP-5792)
      console.log('üì° Sending batch calls...');
      
      const config = getWagmiConfig();
      console.log('üîç Config check:', !!config, 'Chain:', chain?.id, 'Account:', address);
      
      let result;
      try {
        result = await sendCalls(config, {
          calls,
          account: address,
        });
        
        if (!result || !result.id) {
          throw new Error('No valid batch ID received from sendCalls');
        }
        
        console.log('‚úÖ Batch calls sent:', result.id);
        currentBatchId = result.id;
      } catch (sendError) {
        const errorMessage = sendError instanceof Error ? sendError.message : String(sendError);
        
        if (errorMessage.includes('User rejected') || 
            errorMessage.includes('rejected') ||
            errorMessage.includes('cancelled') ||
            errorMessage.includes('denied') ||
            errorMessage.includes('ACTION_REJECTED')) {
          
          console.log('üö´ Transaction was cancelled by user during sendCalls');
          setError('Transaction cancelled by user');
          setIsSuccess(false);
          return;
        }
        
        // –î–ª—è –¥—Ä—É–≥–∏—Ö –æ—à–∏–±–æ–∫ - –ø—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –¥–∞–ª—å—à–µ
        throw sendError;
      }
      
      // –¢–æ–ª—å–∫–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º ID –µ—Å–ª–∏ sendCalls –ø—Ä–æ—à–µ–ª —É—Å–ø–µ—à–Ω–æ
      setBatchId(currentBatchId);
      setTxHash(currentBatchId); // sendCalls –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç batch ID

      // –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å batch calls —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç UnknownBundleIdError
      console.log('‚è≥ Waiting for batch execution...');
      
      try {
        const config = getWagmiConfig();
        
        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å ID
        if (!currentBatchId || typeof currentBatchId !== 'string') {
          throw new Error('Invalid batch ID received');
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å bundle —Å timeout –∏ retry –ª–æ–≥–∏–∫–æ–π
        let retryCount = 0;
        const maxRetries = 3;
        let status;
        
        while (retryCount < maxRetries) {
          try {
            // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –±–µ–∑ –æ–∂–∏–¥–∞–Ω–∏—è
            status = await getCallsStatus(config, { id: currentBatchId });
            
            if (status.status === 'pending') {
              // –ï—Å–ª–∏ pending, –∂–¥–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
              status = await waitForCallsStatus(config, {
                id: currentBatchId,
                timeout: 60000, // –£–º–µ–Ω—å—à–µ–Ω–Ω—ã–π timeout - 1 –º–∏–Ω—É—Ç–∞
              });
            }
            
            break; // –ï—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–∏–ª–∏ —Å—Ç–∞—Ç—É—Å, –≤—ã—Ö–æ–¥–∏–º –∏–∑ retry loop
            
          } catch (retryError) {
            retryCount++;
            const retryErrorMessage = retryError instanceof Error ? retryError.message : String(retryError);
            
            if (retryErrorMessage.includes('UnknownBundleIdError') || 
                retryErrorMessage.includes('bundle id is unknown') ||
                retryErrorMessage.includes('No matching bundle found')) {
              
              if (retryCount >= maxRetries) {
                console.log('üö´ Bundle ID became invalid - transaction likely cancelled');
                setError('Transaction was cancelled or timed out');
                setIsSuccess(false);
                setBatchId(null);
                setTxHash(null);
                return;
              }
              
              // Wait before retry
              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
              console.log(`üîÑ Retrying status check (${retryCount}/${maxRetries})...`);
            } else {
              throw retryError; // Re-throw non-bundle-id errors
            }
          }
        }

        console.log('‚úÖ Batch execution completed:', status);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —É—Å–ø–µ—à–Ω—ã–µ —Å—Ç–∞—Ç—É—Å—ã
        const successStatuses = ['success'];
        
        if (status && status.status && successStatuses.includes(status.status)) {
          setIsSuccess(true);
          // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–π tx hash –∏–∑ —Å—Ç–∞—Ç—É—Å–∞
          if (status.receipts && status.receipts.length > 0) {
            setTxHash(status.receipts[0].transactionHash);
          }
          console.log('üéâ Batch swap completed successfully!');
        } else if (status && status.status === 'pending') {
          // If still pending after timeout, consider it successful but pending
          setIsSuccess(true);
          console.log('‚è≥ Transaction is still pending but likely will complete');
        } else if (status && status.status === 'failure') {
          console.log('‚ùå Transaction failed');
          setError('Transaction failed');
          setIsSuccess(false);
        } else {
          console.warn('‚ö†Ô∏è Unexpected status:', status?.status);
          // –ù–µ –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ–º –æ—à–∏–±–∫—É, —Ç–∞–∫ –∫–∞–∫ batch –º–æ–≥ –≤—ã–ø–æ–ª–Ω–∏—Ç—å—Å—è —É—Å–ø–µ—à–Ω–æ
          setIsSuccess(true);
        }
        
      } catch (statusError) {
        console.error('‚ùå Batch status error:', statusError);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ—à–∏–±–∫–∞ —Å–≤—è–∑–∞–Ω–Ω–æ–π —Å –æ—Ç–º–µ–Ω–æ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
        const errorMessage = statusError instanceof Error ? statusError.message : String(statusError);
        
        if (errorMessage.includes('UnknownBundleIdError') || 
            errorMessage.includes('bundle id is unknown') ||
            errorMessage.includes('No matching bundle found') ||
            errorMessage.includes('User rejected') ||
            errorMessage.includes('rejected') ||
            errorMessage.includes('cancelled') ||
            errorMessage.includes('denied')) {
          
          console.log('üö´ Transaction was cancelled or bundle not found');
          setError('Transaction was cancelled by user');
          setIsSuccess(false);
          
          // Reset batch ID since it's invalid
          setBatchId(null);
          setTxHash(null);
          return; // –í—ã—Ö–æ–¥–∏–º –±–µ–∑ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ success
        }
        
        // –î–ª—è –¥—Ä—É–≥–∏—Ö –æ—à–∏–±–æ–∫ - –ø–æ–º–µ—á–∞–µ–º –∫–∞–∫ —É—Å–ø–µ—à–Ω—ã–π (–≤–æ–∑–º–æ–∂–Ω–æ batch –≤—ã–ø–æ–ª–Ω–∏–ª—Å—è)
        setIsSuccess(true);
        console.log('üîÑ Assuming success despite status error');
      }

    } catch (err) {
      console.error('‚ùå Simple batch swap error:', err);
      setError(err instanceof Error ? err.message : 'Unknown error occurred');
    } finally {
      setIsLoading(false);
    }
  }, [address, chain]);

  const resetState = useCallback(() => {
    setIsLoading(false);
    setError(null);
    setTxHash(null);
    setBatchId(null);
    setIsSuccess(false);
    setCallsCount(0);
  }, []);

  return {
    executeBatchSwap,
    resetState,
    isLoading,
    error,
    txHash,
    batchId,
    isSuccess: isSuccess && !!transactionReceipt,
    callsCount,
  };
}

